package eu.isygoit.helper;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import java.security.*;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

/**
 * The SecurityHelper class provides various cryptographic utilities such as key generation,
 * AES wrapping, encryption/decryption, and random sequence generation.
 */
public interface SecurityHelper {

    Logger logger = LoggerFactory.getLogger(SecurityHelper.class);

    public static final String AES_ALGORITHM = "AES";
    public static final String AES_WRAP_TRANSFORMATION = "AESWrap";
    public static final String AES_CIPHER_TRANSFORMATION = "AES/ECB/PKCS5Padding";

    /**
     * Generates an ECPrivateKey from a hexadecimal string.
     *
     * @param hexPrivateKey the hexadecimal string representation of the private key
     * @return the ECPrivateKey or null if an error occurs
     */
    public static ECPrivateKey generateECPrivateKeyFromHex(String hexPrivateKey) {
        try {
            var encodedKey = ByteArrayHelper.convertHexToBytes(hexPrivateKey);
            var keyFactory = KeyFactory.getInstance("ECDSA");
            var privateKeySpec = new PKCS8EncodedKeySpec(encodedKey);
            return (ECPrivateKey) keyFactory.generatePrivate(privateKeySpec);
        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            logger.error("Error generating ECPrivateKey: {}", e.getMessage());
        }
        return null;
    }

    /**
     * Generates an ECPublicKey from a hexadecimal string.
     *
     * @param hexPublicKey the hexadecimal string representation of the public key
     * @return the ECPublicKey or null if an error occurs
     */
    public static ECPublicKey generateECPublicKeyFromHex(String hexPublicKey) {
        try {
            var encodedKey = ByteArrayHelper.convertHexToBytes(hexPublicKey);
            var keyFactory = KeyFactory.getInstance("ECDSA");
            var publicKeySpec = new X509EncodedKeySpec(encodedKey);
            return (ECPublicKey) keyFactory.generatePublic(publicKeySpec);
        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            logger.error("Error generating ECPublicKey: {}", e.getMessage());
        }
        return null;
    }

    /**
     * Generates a random sequence of bytes, typically used as a challenge.
     * The length of the sequence is fixed to 16 bytes.
     *
     * @return the generated byte array
     */
    public static byte[] generateRandomByteSequence() {
        var secureRandom = new SecureRandom();
        var byteSequence = new byte[16];

        for (int i = 0; i < byteSequence.length; i++) {
            var byteArray = new byte[1];

            // Only allow printable characters (ASCII range 32-126)
            do {
                secureRandom.nextBytes(byteArray);
            } while (byteArray[0] < 32 || byteArray[0] > 126);

            byteSequence[i] = byteArray[0];
        }

        logger.debug("Generated random byte sequence: {}", ByteArrayHelper.convertBytesToHex(byteSequence));
        return byteSequence;
    }

    /**
     * Wraps the given AES key using the specified secret key.
     *
     * @param hexSecretKey the secret key in hexadecimal format
     * @param hexDataKey   the AES key data to be wrapped, in hexadecimal format
     * @return the wrapped key as a hexadecimal string or null if an error occurs
     */
    public static String wrapAESKeyWithSecretKey(String hexSecretKey, String hexDataKey) {
        try {
            var secretKey = new SecretKeySpec(ByteArrayHelper.convertHexToBytes(hexSecretKey), AES_ALGORITHM);
            var dataKey = new SecretKeySpec(ByteArrayHelper.convertHexToBytes(hexDataKey), AES_ALGORITHM);

            // Initialize the cipher in wrap mode
            var cipher = Cipher.getInstance(AES_WRAP_TRANSFORMATION);
            cipher.init(Cipher.WRAP_MODE, secretKey);
            var wrappedKeyBytes = cipher.wrap(dataKey);

            var wrappedKeyHex = ByteArrayHelper.convertBytesToHex(wrappedKeyBytes);
            logger.debug("Wrapped AES key: {}", wrappedKeyHex);
            return wrappedKeyHex;
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
                 IllegalBlockSizeException e) {
            logger.error("Error wrapping AES key: {}", e.getMessage());
        }
        return null;
    }

    /**
     * Encrypts the given plaintext using AES encryption.
     *
     * @param hexSecretKey the AES key in hexadecimal format
     * @param plaintext    the plaintext to encrypt
     * @return the encrypted ciphertext as a hexadecimal string
     */
    public static String encryptWithAES(String hexSecretKey, String plaintext) {
        try {
            var secretKey = new SecretKeySpec(ByteArrayHelper.convertHexToBytes(hexSecretKey), AES_ALGORITHM);
            var cipher = Cipher.getInstance(AES_CIPHER_TRANSFORMATION);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            var encryptedBytes = cipher.doFinal(plaintext.getBytes());

            return ByteArrayHelper.convertBytesToHex(encryptedBytes);
        } catch (Exception e) {
            logger.error("Error encrypting with AES: {}", e.getMessage());
        }
        return null;
    }

    /**
     * Decrypts the given ciphertext using AES decryption.
     *
     * @param hexSecretKey  the AES key in hexadecimal format
     * @param hexCiphertext the ciphertext to decrypt
     * @return the decrypted plaintext as a string
     */
    public static String decryptWithAES(String hexSecretKey, String hexCiphertext) {
        try {
            var secretKey = new SecretKeySpec(ByteArrayHelper.convertHexToBytes(hexSecretKey), AES_ALGORITHM);
            var cipher = Cipher.getInstance(AES_CIPHER_TRANSFORMATION);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);

            var decryptedBytes = cipher.doFinal(ByteArrayHelper.convertHexToBytes(hexCiphertext));
            return new String(decryptedBytes);
        } catch (Exception e) {
            logger.error("Error decrypting with AES: {}", e.getMessage());
        }
        return null;
    }

    /**
     * Validates if a string is a valid hexadecimal representation.
     *
     * @param hexString the string to validate
     * @return true if the string is a valid hex string, false otherwise
     */
    public static boolean isHexStringValid(String hexString) {
        return hexString != null && hexString.matches("^[0-9a-fA-F]+$");
    }

    /**
     * Generates a cryptographic salt of the specified length.
     *
     * @param saltLength the length of the salt
     * @return the generated salt as a byte array
     */
    public static byte[] generateCryptographicSalt(int saltLength) {
        var secureRandom = new SecureRandom();
        var salt = new byte[saltLength];
        secureRandom.nextBytes(salt);
        return salt;
    }

    /**
     * Generates a KeyPair for asymmetric encryption (e.g., RSA, ECDSA).
     *
     * @param algorithm the encryption algorithm to use (e.g., RSA)
     * @param keySize   the size of the key (e.g., 2048 for RSA)
     * @return the generated KeyPair or null if an error occurs
     */
    public static KeyPair generateKeyPairForAlgorithm(String algorithm, int keySize) {
        try {
            var keyPairGenerator = KeyPairGenerator.getInstance(algorithm);
            keyPairGenerator.initialize(keySize);
            return keyPairGenerator.generateKeyPair();
        } catch (NoSuchAlgorithmException e) {
            logger.error("Error generating key pair for {}: {}", algorithm, e.getMessage());
        }
        return null;
    }
}